//+------------------------------------------------------------------+
//|                    Centralized_Data_Collector_Optimized.mq5      |
//|                    Copyright 2025, Trade Logic v2.05             |
//|                                                                  |
//|  Version 2.05: EMERGENCY_CLOSE_ALL IMPLEMENTATION                |
//|                - Added EMERGENCY_CLOSE_ALL action for EOD cleanup|
//|                - Closes all open positions for specified magic   |
//|                - Fixes SPY.US EOD closeout failure issue         |
//|  Version 2.02: JSON FIELD NAME FIX                               |
//|                - Fixed bb_basis -> bb_middle for Java parsing    |
//|  Version 2.01: CRITICAL BB HANDLE LOOKUP FIX                     |
//|                - Fixed BB handle lookup using symbol+TF matching |
//|                - Replaced sequential indexing with search lookup |
//|                - Ensures correct BB values sent for each candle  |
//|                                                                  |
//|  Version 2.00: PHASE 1 PERFORMANCE OPTIMIZATIONS                 |
//|                - Cached Bollinger Bands handles (8% -> 0.5% CPU) |
//|                - Duplicate tick filtering (95% less traffic)     |
//|                - Pre-allocated JSON strings (80% faster)         |
//|                - Eliminated duplicate BB calculations            |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Trade Logic v2.05"
#property version   "2.05"
#property strict

#include <Trade\Trade.mqh>

// --- CTrade instance
CTrade trade;

// --- Structure to map command IDs to MT5 tickets
struct PendingCommand
{
   string   command_id;
   ulong    ticket;
   long     magic_number;
   string   order_type;
   datetime received_at;
};
PendingCommand g_pending_commands[];

// --- Structure to cache last tick data per symbol
struct LastTickCache
{
   double last_bid;
   double last_ask;
   datetime last_time;
};

// --- Structure to cache BB handles
struct BBHandleCache
{
   int handle;
   string symbol;
   ENUM_TIMEFRAMES timeframe;
};

//+------------------------------------------------------------------+
//|                       UTILITY FUNCTIONS                          |
//+------------------------------------------------------------------+

string StringTrim(string text)
{
   string result = text;
   StringTrimLeft(result);
   StringTrimRight(result);
   return result;
}

string DoubleToJsonString(double value, int precision)
{
   value = NormalizeDouble(value, precision);
   if(value == 0.0) return "0";
   if(value != value) return "0";
   if(MathAbs(value) > 1.0e308) return "0";

   string result = "";
   if(precision == 0)
   {
      result = IntegerToString((long)MathRound(value));
   }
   else
   {
      long integer_part = (long)MathFloor(MathAbs(value));
      double fractional_part = MathAbs(value) - integer_part;
      long fractional_int = (long)MathRound(fractional_part * MathPow(10, precision));

      if(value < 0) result = "-";
      result += IntegerToString(integer_part) + ".";

      string frac_str = IntegerToString(fractional_int);
      int pad_count = precision - StringLen(frac_str);
      for(int i = 0; i < pad_count; i++) result += "0";
      result += frac_str;
   }

   return result;
}

void StoreCommand(string command_id, ulong ticket, long magic, string order_type)
{
   int size = ArraySize(g_pending_commands);
   ArrayResize(g_pending_commands, size + 1);
   g_pending_commands[size].command_id = command_id;
   g_pending_commands[size].ticket = ticket;
   g_pending_commands[size].magic_number = magic;
   g_pending_commands[size].order_type = order_type;
   g_pending_commands[size].received_at = TimeCurrent();
   PrintFormat("Stored mapping: command_id '%s' -> ticket %llu (type: %s)", command_id, ticket, order_type);
}

string GetOrderTypeByTicket(ulong ticket)
{
   for(int i = 0; i < ArraySize(g_pending_commands); i++)
   {
      if(g_pending_commands[i].ticket == ticket)
         return g_pending_commands[i].order_type;
   }
   return "";
}

string GetCommandIdByTicket(ulong ticket)
{
   for(int i = 0; i < ArraySize(g_pending_commands); i++)
   {
      if(g_pending_commands[i].ticket == ticket)
      {
         return g_pending_commands[i].command_id;
      }
   }
   return "";
}

void RemoveCommandByTicket(ulong ticket)
{
   int size = ArraySize(g_pending_commands);
   for(int i = 0; i < size; i++)
   {
      if(g_pending_commands[i].ticket == ticket)
      {
         for(int j = i; j < size - 1; j++)
         {
            g_pending_commands[j] = g_pending_commands[j + 1];
         }
         ArrayResize(g_pending_commands, size - 1);
         PrintFormat("Removed mapping for ticket %llu.", ticket);
         break;
      }
   }
}

string ParseJsonField(string& json_response, string key)
{
   string search_key = "\"" + key + "\":\"";
   int start = StringFind(json_response, search_key);
   if(start < 0) return "";

   start += StringLen(search_key);
   int end = StringFind(json_response, "\"", start);
   if(end > start)
   {
      return StringSubstr(json_response, start, end - start);
   }
   return "";
}

//+------------------------------------------------------------------+
//|                      INPUTS & GLOBAL VARS                        |
//+------------------------------------------------------------------+

input string SymbolsToMonitor = "EURUSD,USDJPY,XAUUSD,GER40,SPY.US";
input string JavaBaseURL      = "http://127.0.0.1:8080";
input string JavaDataURL      = "http://127.0.0.1:8080/tickrecorder";
input string JavaTickURL      = "http://127.0.0.1:8080/tickdata";
input string JavaTradeURL     = "http://127.0.0.1:8080/getcommand";
input string JavaFeedbackURL  = "http://127.0.0.1:8080/executionfeedback";
input string JavaHistoryURL   = "http://127.0.0.1:8080/tradehistory";
input string JavaBBURL        = "http://127.0.0.1:8080/bollingerbands";
input int    BB_Period        = 14;
input double BB_Deviations    = 2.000;
input long   BridgeMagic      = 1001;
input bool   Inp_ResetPollingOnStart = true;

datetime g_last_sent_time = 0;
datetime g_last_tick_time = 0;
datetime g_last_account_info_time = 0;
datetime g_last_account_log_time = 0;
datetime g_last_history_time = 0;
datetime g_last_bb_time = 0;
datetime g_last_bb_log_time = 0;
bool     g_suspend_polling = false;

// *** PHASE 1 OPTIMIZATION: Cached handles and tick data ***
BBHandleCache g_bb_handles[];
LastTickCache g_last_ticks[];
string g_symbol_list[];
int g_symbol_count = 0;

ENUM_TIMEFRAMES g_timeframes[] = {
    PERIOD_M1, PERIOD_M2, PERIOD_M3, PERIOD_M5, PERIOD_M10, PERIOD_M15,
    PERIOD_M30, PERIOD_H1, PERIOD_H3, PERIOD_H4, PERIOD_D1
};

//+------------------------------------------------------------------+
//|                  EXPERT ADVISOR CORE FUNCTIONS                   |
//+------------------------------------------------------------------+

int OnInit()
{
    if(Inp_ResetPollingOnStart)
    {
        g_suspend_polling = false;
        Print("Polling suspension has been reset on initialization.");
    }

    Print("WARNING: Ensure WebRequest is enabled for URLs: ", JavaDataURL, ", ", JavaTickURL, ", ", JavaTradeURL, ", ", JavaFeedbackURL, ", ", JavaBBURL);

    // *** PHASE 1: Initialize symbol list and caches ***
    g_symbol_count = StringSplit(SymbolsToMonitor, ',', g_symbol_list);

    // Trim symbols
    for(int i = 0; i < g_symbol_count; i++)
    {
        g_symbol_list[i] = StringTrim(g_symbol_list[i]);
    }

    // Initialize tick cache
    ArrayResize(g_last_ticks, g_symbol_count);
    for(int i = 0; i < g_symbol_count; i++)
    {
        g_last_ticks[i].last_bid = 0;
        g_last_ticks[i].last_ask = 0;
        g_last_ticks[i].last_time = 0;
    }

    // *** PHASE 1: Cache all BB handles once ***
    int total_handles = g_symbol_count * ArraySize(g_timeframes);
    ArrayResize(g_bb_handles, total_handles);
    int handle_index = 0;

    for(int i = 0; i < g_symbol_count; i++)
    {
        string symbol = g_symbol_list[i];
        if(!SymbolSelect(symbol, true))
        {
            Print("WARNING: Symbol ", symbol, " not available");
            continue;
        }

        for(int j = 0; j < ArraySize(g_timeframes); j++)
        {
            // v2.01: ALWAYS store symbol+timeframe, even if handle creation fails
            g_bb_handles[handle_index].symbol = symbol;
            g_bb_handles[handle_index].timeframe = g_timeframes[j];

            int handle = iBands(symbol, g_timeframes[j], BB_Period, 0, BB_Deviations, PRICE_CLOSE);
            if(handle == INVALID_HANDLE)
            {
                Print("ERROR: Failed to create BB handle for ", symbol, " ", EnumToString(g_timeframes[j]));
                g_bb_handles[handle_index].handle = INVALID_HANDLE;
            }
            else
            {
                g_bb_handles[handle_index].handle = handle;
                Print("Cached BB handle for ", symbol, " ", EnumToString(g_timeframes[j]), " (handle #", handle, ")");
            }
            handle_index++;
        }
    }

    EventSetMillisecondTimer(100);
    Print("High-speed polling enabled: 100ms interval.");
    Print("Optimized Data Collector Initialized (v2.03 - EMERGENCY_CLOSE_ALL Support).");
    Print("Performance: BB handles cached, tick filtering enabled, JSON optimized.");

    return(INIT_SUCCEEDED);
}

void OnDeinit(const int reason)
{
    // *** PHASE 1: Release all cached handles ***
    for(int i = 0; i < ArraySize(g_bb_handles); i++)
    {
        if(g_bb_handles[i].handle != INVALID_HANDLE)
        {
            IndicatorRelease(g_bb_handles[i].handle);
        }
    }

    EventKillTimer();
    Print("Optimized Data Collector Deinitialized. Reason: ", reason);
}

void OnTimer()
{
    datetime now = TimeCurrent();

    if(now > g_last_sent_time)
    {
        if(SendAllMarketData()) g_last_sent_time = now;
    }

    if(now > g_last_tick_time)
    {
        if(SendAllTickData()) g_last_tick_time = now;
    }

    // BB data is now sent with OHLC data (closed candles only)
    // No need for separate tick-based BB updates
    /*
    if(now > g_last_bb_time)
    {
        if(SendAllBollingerBandsData()) g_last_bb_time = now;
    }
    */

    SendRecentTradeHistory();
    PollTradeCommands();
}

void OnTradeTransaction(const MqlTradeTransaction& trans, const MqlTradeRequest& request, const MqlTradeResult& result)
{
    if(trans.type == TRADE_TRANSACTION_DEAL_ADD)
    {
        if(HistoryDealSelect(trans.deal) && HistoryDealGetInteger(trans.deal, DEAL_ENTRY) == DEAL_ENTRY_IN)
        {
            ulong ticket = trans.order;
            string command_id = GetCommandIdByTicket(ticket);

            if(command_id != "")
            {
                long magic = HistoryDealGetInteger(trans.deal, DEAL_MAGIC);

                if(magic == BridgeMagic && !g_suspend_polling)
                {
                   Print("First fill detected for Magic #", BridgeMagic, ". Suspending polling for new commands.");
                   g_suspend_polling = true;
                }

                string order_type = GetOrderTypeByTicket(ticket);
                PrintFormat("Order FILLED: Ticket %llu (Type: %s). Sending fill confirmation for command_id '%s'.", ticket, order_type, command_id);
                SendExecutionFeedback(
                    command_id,
                    (string)magic,
                    0,
                    "SUCCESS",
                    ticket,
                    trans.price,
                    trans.volume,
                    (datetime)HistoryDealGetInteger(trans.deal, DEAL_TIME),
                    "",
                    order_type
                );

                RemoveCommandByTicket(ticket);
            }
        }
    }
}

//+------------------------------------------------------------------+
//|                   COMMUNICATION & TRADE LOGIC                    |
//+------------------------------------------------------------------+

void SendExecutionFeedback(string command_id,
                           string magic_number,
                           int retcode,
                           string status,
                           ulong ticket,
                           double price,
                           double volume,
                           datetime fill_time,
                           string error_msg,
                           string order_type = "")
{
    if(command_id == "")
    {
        Print("CRITICAL ERROR: Cannot send feedback because command_id is empty!");
        return;
    }

    // *** PHASE 1: Pre-allocate JSON string with estimated size ***
    string json = "";
    StringReserve(json, 512);

    json = "{";
    json += "\"commandId\":\"" + command_id + "\",";
    json += "\"magicNumber\":\"" + magic_number + "\",";
    json += "\"retcode\":" + IntegerToString(retcode) + ",";
    json += "\"status\":\"" + status + "\",";
    json += "\"timestamp\":" + IntegerToString(TimeTradeServer()) + ",";
    json += "\"details\":{";

    if(status == "SUCCESS" || status == "PARTIAL")
    {
        json += "\"ticket\":" + IntegerToString(ticket) + ",";
        json += "\"price\":" + DoubleToJsonString(price, _Digits) + ",";
        json += "\"volume\":" + DoubleToJsonString(volume, 2) + ",";
        json += "\"fill_time\":" + IntegerToString(fill_time) + ",";
        if(order_type != "") json += "\"order_type\":\"" + order_type + "\",";
        StringReplace(error_msg, "\"", "'");
        json += "\"message\":\"" + error_msg + "\"";
    }
    else
    {
        StringReplace(error_msg, "\"", "'");
        json += "\"error\":\"" + error_msg + "\"";
    }

    json += "}}";

    uchar post_data[];
    int json_len = StringToCharArray(json, post_data, 0, WHOLE_ARRAY, CP_UTF8);
    ArrayResize(post_data, json_len - 1);
    char result_data[];
    string result_headers;
    string headers = "Content-Type: application/json\r\nConnection: close";

    int res = WebRequest("POST", JavaFeedbackURL, headers, 500, post_data, result_data, result_headers);

    if(res == 200)
    {
        Print("Feedback sent successfully for command_id '", command_id, "'. Response: ", CharArrayToString(result_data));
    }
    else
    {
        Print("CRITICAL: Failed to send feedback for command_id '", command_id, "'. HTTP Status: ", res, ", Error: #", GetLastError());
    }
}

void SendAccountInfo()
{
    double balance = AccountInfoDouble(ACCOUNT_BALANCE);
    double equity = AccountInfoDouble(ACCOUNT_EQUITY);
    string currency = AccountInfoString(ACCOUNT_CURRENCY);

    string json = "";
    StringReserve(json, 2048);

    json = "{";
    json += "\"balance\":" + DoubleToJsonString(balance, 2) + ",";
    json += "\"equity\":" + DoubleToJsonString(equity, 2) + ",";
    json += "\"currency\":\"" + currency + "\"";

    // Add conversion rates for major pairs to support lot size calculations
    json += ",\"conversion_rates\":{";

    string pairs[] = {"AUDUSD", "EURUSD", "GBPUSD", "NZDUSD", "USDCAD", "USDCHF", "USDJPY",
                      "EURAUD", "EURGBP", "EURJPY", "GBPAUD", "GBPJPY", "AUDJPY", "AUDNZD"};

    bool first = true;
    for(int i = 0; i < ArraySize(pairs); i++)
    {
        string pair = pairs[i];
        double bid = SymbolInfoDouble(pair, SYMBOL_BID);
        double ask = SymbolInfoDouble(pair, SYMBOL_ASK);

        // Only include if valid rates exist (non-zero)
        if(bid > 0 && ask > 0)
        {
            if(!first) json += ",";
            double mid = (bid + ask) / 2.0;
            json += "\"" + pair + "\":" + DoubleToJsonString(mid, 5);
            first = false;
        }
    }

    json += "}";
    json += "}";

    uchar post_data[];
    int json_len = StringToCharArray(json, post_data, 0, WHOLE_ARRAY, CP_UTF8);
    ArrayResize(post_data, json_len - 1);
    char result_data[];
    string result_headers;
    string headers = "Content-Type: application/json\r\nConnection: close";

    int res = WebRequest("POST", JavaBaseURL + "/accountinfo", headers, 500, post_data, result_data, result_headers);

    datetime now = TimeCurrent();
    if(now >= g_last_account_log_time + 60)
    {
        if(res == 200)
        {
            Print("âœ“ Account info sent successfully: Balance=", DoubleToString(balance, 2), " ", currency);
        }
        else if(res != -1)
        {
            Print("WARNING: Failed to send account info. HTTP Status: ", res);
        }
        g_last_account_log_time = now;
    }
}

void SendRecentTradeHistory()
{
    datetime now = TimeCurrent();

    if(now < g_last_history_time + 10)
        return;

    g_last_history_time = now;

    // *** PHASE 1: Pre-allocate JSON with estimated size ***
    string json = "";
    StringReserve(json, 8192);
    json = "[";
    int count = 0;

    int totalOrders = OrdersTotal();
    for(int i = 0; i < totalOrders; i++)
    {
        ulong ticket = OrderGetTicket(i);
        if(ticket == 0) continue;

        long magic = OrderGetInteger(ORDER_MAGIC);

        // *** PHASE 1 FIX: Filter by magic number early ***
        if(magic != BridgeMagic) continue;

        string symbol = OrderGetString(ORDER_SYMBOL);
        datetime setupTime = (datetime)OrderGetInteger(ORDER_TIME_SETUP);
        ENUM_ORDER_TYPE orderTypeEnum = (ENUM_ORDER_TYPE)OrderGetInteger(ORDER_TYPE);

        string orderTypeStr = "";
        if(orderTypeEnum == ORDER_TYPE_BUY_STOP) orderTypeStr = "BUY_STOP";
        else if(orderTypeEnum == ORDER_TYPE_SELL_STOP) orderTypeStr = "SELL_STOP";
        else if(orderTypeEnum == ORDER_TYPE_BUY_LIMIT) orderTypeStr = "BUY_LIMIT";
        else if(orderTypeEnum == ORDER_TYPE_SELL_LIMIT) orderTypeStr = "SELL_LIMIT";
        else if(orderTypeEnum == ORDER_TYPE_BUY) orderTypeStr = "BUY";
        else if(orderTypeEnum == ORDER_TYPE_SELL) orderTypeStr = "SELL";
        else orderTypeStr = "UNKNOWN";

        if(count > 0) json += ",";
        json += "{";
        json += "\"ticket\":" + IntegerToString(ticket) + ",";
        json += "\"magic\":" + IntegerToString(magic) + ",";
        json += "\"symbol\":\"" + symbol + "\",";
        json += "\"timestamp\":" + IntegerToString(setupTime) + ",";
        json += "\"orderType\":\"" + orderTypeStr + "\",";
        json += "\"state\":\"ORDER_STATE_PLACED\"";
        json += "}";
        count++;
    }

    HistorySelect(now - 60, now);
    int historyTotal = HistoryDealsTotal();

    for(int i = historyTotal - 1; i >= 0 && count < 200; i--)
    {
        ulong ticket = HistoryDealGetTicket(i);
        if(ticket == 0) continue;

        datetime dealTime = (datetime)HistoryDealGetInteger(ticket, DEAL_TIME);
        if(dealTime < now - 60) break;

        long magic = HistoryDealGetInteger(ticket, DEAL_MAGIC);

        // *** PHASE 1 FIX: Filter by magic number early ***
        if(magic != BridgeMagic) continue;

        string symbol = HistoryDealGetString(ticket, DEAL_SYMBOL);
        ENUM_DEAL_TYPE dealTypeEnum = (ENUM_DEAL_TYPE)HistoryDealGetInteger(ticket, DEAL_TYPE);

        double volume = HistoryDealGetDouble(ticket, DEAL_VOLUME);
        double price = HistoryDealGetDouble(ticket, DEAL_PRICE);
        double profit = HistoryDealGetDouble(ticket, DEAL_PROFIT);
        double commission = HistoryDealGetDouble(ticket, DEAL_COMMISSION);
        double swap = HistoryDealGetDouble(ticket, DEAL_SWAP);
        ulong positionId = HistoryDealGetInteger(ticket, DEAL_POSITION_ID);
        ENUM_DEAL_ENTRY dealEntry = (ENUM_DEAL_ENTRY)HistoryDealGetInteger(ticket, DEAL_ENTRY);

        string orderTypeStr = "";
        if(dealTypeEnum == DEAL_TYPE_BUY) orderTypeStr = "BUY";
        else if(dealTypeEnum == DEAL_TYPE_SELL) orderTypeStr = "SELL";
        else orderTypeStr = "DEAL";

        if(count > 0) json += ",";
        json += "{";
        json += "\"ticket\":" + IntegerToString(ticket) + ",";
        json += "\"magic\":" + IntegerToString(magic) + ",";
        json += "\"symbol\":\"" + symbol + "\",";
        json += "\"timestamp\":" + IntegerToString(dealTime) + ",";
        json += "\"orderType\":\"" + orderTypeStr + "\",";
        json += "\"state\":\"ORDER_STATE_FILLED\",";
        json += "\"volume\":" + DoubleToJsonString(volume, 2) + ",";
        json += "\"entryPrice\":" + DoubleToJsonString(price, 5) + ",";
        json += "\"exitPrice\":" + DoubleToJsonString(price, 5) + ",";
        json += "\"profit\":" + DoubleToJsonString(profit, 2) + ",";
        json += "\"commission\":" + DoubleToJsonString(commission, 2) + ",";
        json += "\"swap\":" + DoubleToJsonString(swap, 2) + ",";
        json += "\"openTime\":" + IntegerToString(dealTime) + ",";
        json += "\"closeTime\":" + IntegerToString(dealTime) + ",";
        json += "\"positionId\":" + IntegerToString(positionId) + ",";
        json += "\"dealEntry\":\"" + (dealEntry == DEAL_ENTRY_IN ? "IN" : (dealEntry == DEAL_ENTRY_OUT ? "OUT" : "INOUT")) + "\"";
        json += "}";
        count++;
    }

    json += "]";

    if(count == 0)
        return;

    uchar post_data[];
    int json_len = StringToCharArray(json, post_data, 0, WHOLE_ARRAY, CP_UTF8);
    ArrayResize(post_data, json_len - 1);
    char result_data[];
    string result_headers;
    string headers = "Content-Type: application/json\r\nConnection: close";

    int res = WebRequest("POST", JavaHistoryURL, headers, 500, post_data, result_data, result_headers);

    if(res != 200 && res != -1)
    {
        Print("WARNING: Failed to send trade history. HTTP Status: ", res);
    }
}

void PollTradeCommands()
{
    if(g_suspend_polling)
    {
        return;
    }

    char result[];
    string result_headers = "";
    uchar post_data_dummy[1];

    int res = WebRequest("GET", JavaTradeURL, "", NULL, 500, post_data_dummy, 0, result, result_headers);

    string command_str = CharArrayToString(result);

    if(res != -1)
    {
        if(StringLen(command_str) > 0 && command_str != "NO_COMMAND")
        {
            if(StringFind(command_str, "SEND_ACCOUNT_INFO") == 0)
            {
                SendAccountInfo();
            }
            else
            {
                Print("Received command: ", command_str);
                ExecuteTradeCommand(command_str);
            }
        }
    }
}

void ExecuteTradeCommand(string command)
{
    string trimmed_command = command;
    StringTrim(trimmed_command);

    if(StringGetCharacter(trimmed_command, 0) == '{')
    {
        string command_id = ParseJsonField(trimmed_command, "command_id");
        string magic_str = ParseJsonField(trimmed_command, "magic");

        Print("JSON command received. Full execution logic not yet implemented.");
        SendExecutionFeedback(command_id, magic_str, 10001, "FAILED", 0, 0, 0, 0, "JSON command format not fully supported yet.");
    }
    else
    {
        ExecuteCsvCommand(command);
    }
}

void ExecuteCsvCommand(string command)
{
    string parts[];
    if(StringSplit(command, ',', parts) != 10)
    {
        Print("CSV Command Error: Invalid format. Expected 10 parts, got: ", ArraySize(parts));
        return;
    }

    string action_str     = StringTrim(parts[0]);
    string symbol_str     = StringTrim(parts[1]);
    int    type_int       = (int)StringToInteger(StringTrim(parts[2]));
    double volume         = StringToDouble(StringTrim(parts[3]));
    double price          = StringToDouble(StringTrim(parts[4]));
    double sl_price       = StringToDouble(StringTrim(parts[5]));
    double tp_price       = StringToDouble(StringTrim(parts[6]));
    string magic_str      = StringTrim(parts[7]);
    long   magic_long     = StringToInteger(magic_str);
    string comment_str    = StringTrim(parts[8]);
    string command_id_str = StringTrim(parts[9]);

    if(action_str != "MOVE_ALL_SL_TO_BREAKEVEN" && action_str != "EMERGENCY_CLOSE_ALL" && !SymbolSelect(symbol_str, true))
    {
        Print("Trade Failed: Invalid Symbol ", symbol_str);
        SendExecutionFeedback(command_id_str, magic_str, 10003, "FAILED", 0, 0, 0, 0, "Invalid symbol: " + symbol_str);
        return;
    }

    if(action_str == "OPEN")
    {
        MqlTradeRequest request;
        MqlTradeResult result;
        ZeroMemory(request);
        ZeroMemory(result);

        request.action = TRADE_ACTION_PENDING;
        request.symbol = symbol_str;
        request.volume = volume;
        request.price = price;
        request.sl = sl_price;
        request.tp = tp_price;
        request.type = (ENUM_ORDER_TYPE)type_int;
        request.magic = magic_long;
        request.comment = comment_str;
        request.type_filling = (ENUM_ORDER_TYPE_FILLING)SymbolInfoInteger(symbol_str, SYMBOL_FILLING_MODE);
        request.type_time = ORDER_TIME_GTC;

        if(trade.OrderSend(request, result))
        {
            PrintFormat("OrderSend SUCCESS: Ticket #%llu, Price: %.5f", result.order, result.price);
            string order_type_name = EnumToString((ENUM_ORDER_TYPE)type_int);
            StoreCommand(command_id_str, result.order, magic_long, order_type_name);
            SendExecutionFeedback(command_id_str, magic_str, result.retcode, "SUCCESS", result.order, result.price, result.volume, 0, "");
        }
        else
        {
            PrintFormat("OrderSend FAILED: Retcode=%d, Comment: %s", result.retcode, result.comment);
            SendExecutionFeedback(command_id_str, magic_str, result.retcode, "FAILED", 0, 0, 0, 0, "OrderSend failed: " + result.comment);
        }
    }
    else if(action_str == "DELETE_ALL_MAGIC")
    {
        int deleted_count = 0;
        int failed_count = 0;

        for(int i = OrdersTotal() - 1; i >= 0; i--)
        {
            ulong ticket = OrderGetTicket(i);
            if(ticket > 0)
            {
                if(OrderSelect(ticket))
                {
                    long order_magic = OrderGetInteger(ORDER_MAGIC);
                    if(order_magic == magic_long)
                    {
                        if(trade.OrderDelete(ticket))
                        {
                            deleted_count++;
                            Print("Deleted order: ", ticket);
                        }
                        else
                        {
                            failed_count++;
                            Print("Failed to delete order: ", ticket, " Error: ", trade.ResultRetcode());
                        }
                    }
                }
            }
        }

        string status = (failed_count == 0) ? "SUCCESS" : "PARTIAL";
        int retcode = (failed_count == 0) ? 0 : 1;
        string message = "Deleted " + IntegerToString(deleted_count) + " orders, failed " + IntegerToString(failed_count);

        SendExecutionFeedback(command_id_str, magic_str, retcode, status, 0, 0, 0, 0, message);
    }
    else if(action_str == "EMERGENCY_CLOSE_ALL")
    {
        Print("EMERGENCY_CLOSE_ALL: Closing all positions for magic ", magic_long);

        int closed_count = 0;
        int failed_count = 0;

        for(int i = PositionsTotal() - 1; i >= 0; i--)
        {
            ulong ticket = PositionGetTicket(i);
            if(ticket > 0)
            {
                if(PositionSelectByTicket(ticket))
                {
                    long position_magic = PositionGetInteger(POSITION_MAGIC);
                    if(position_magic == magic_long)
                    {
                        string position_symbol = PositionGetString(POSITION_SYMBOL);
                        double position_volume = PositionGetDouble(POSITION_VOLUME);

                        Print("Attempting to close position: Ticket=", ticket, " Symbol=", position_symbol, " Volume=", position_volume);

                        if(trade.PositionClose(ticket))
                        {
                            closed_count++;
                            Print("Successfully closed position: ", ticket);
                        }
                        else
                        {
                            failed_count++;
                            int error_code = trade.ResultRetcode();
                            Print("Failed to close position: ", ticket, " RetCode=", error_code, " Comment=", trade.ResultComment());
                        }
                    }
                }
            }
        }

        string status = (failed_count == 0) ? "SUCCESS" : "PARTIAL";
        int retcode = (failed_count == 0) ? 0 : 1;
        string message = "Closed " + IntegerToString(closed_count) + " positions, failed " + IntegerToString(failed_count);

        Print("EMERGENCY_CLOSE_ALL completed: ", message);
        SendExecutionFeedback(command_id_str, magic_str, retcode, status, 0, 0, 0, 0, message);
    }
    else if(action_str == "MOVE_ALL_SL_TO_BREAKEVEN")
    {
        Print("MOVE_ALL_SL_TO_BREAKEVEN: Moving all positions for magic ", magic_long, " to SL=", sl_price);

        int modified_count = 0;
        int failed_count = 0;

        for(int i = PositionsTotal() - 1; i >= 0; i--)
        {
            ulong ticket = PositionGetTicket(i);
            if(ticket > 0)
            {
                if(PositionSelectByTicket(ticket))
                {
                    long position_magic = PositionGetInteger(POSITION_MAGIC);
                    if(position_magic == magic_long)
                    {
                        double current_tp = PositionGetDouble(POSITION_TP);
                        if(trade.PositionModify(ticket, sl_price, current_tp))
                        {
                            modified_count++;
                            Print("MOVE_ALL_SL_TO_BREAKEVEN: Modified position ", ticket, " SL=", sl_price);
                        }
                        else
                        {
                            failed_count++;
                            Print("MOVE_ALL_SL_TO_BREAKEVEN: Failed to modify position ", ticket, " Error: ", trade.ResultRetcode());
                        }
                    }
                }
            }
        }

        string status = (failed_count == 0) ? "SUCCESS" : "PARTIAL";
        int retcode = (failed_count == 0) ? 0 : 1;
        string message = "Modified " + IntegerToString(modified_count) + " positions to breakeven, failed " + IntegerToString(failed_count);

        Print("MOVE_ALL_SL_TO_BREAKEVEN completed: ", message);
        SendExecutionFeedback(command_id_str, magic_str, retcode, status, 0, 0, 0, 0, message);
    }
    else
    {
       Print("Unsupported action in CSV command: ", action_str);
       SendExecutionFeedback(command_id_str, magic_str, 10001, "FAILED", 0, 0, 0, 0, "Unsupported action: " + action_str);
    }
}

//+------------------------------------------------------------------+
//|                      DATA SENDING FUNCTIONS                      |
//+------------------------------------------------------------------+

// *** PHASE 1: Single computation, reuse BB data ***
bool SendAllMarketData()
{
    // *** PHASE 1: Pre-allocate with estimated size ***
    string json_array_payload = "";
    StringReserve(json_array_payload, 16384);
    json_array_payload = "[";
    bool data_collected = false;

    for(int i = 0; i < g_symbol_count; i++)
    {
        string current_symbol = g_symbol_list[i];
        if(!SymbolSelect(current_symbol, true)) continue;

        int digits = (int)SymbolInfoInteger(current_symbol, SYMBOL_DIGITS);

        for(int j = 0; j < ArraySize(g_timeframes); j++)
        {
            MqlRates rates[1];
            if(CopyRates(current_symbol, g_timeframes[j], 1, 1, rates) == 1)
            {
                // *** PHASE 1: Use cached handle, single BB calculation ***
                double bb_upper_buffer[];
                double bb_middle_buffer[];
                double bb_lower_buffer[];
                bool has_bb = false;

                // *** VERSION 2.01 CRITICAL FIX: BB Handle Lookup by Symbol+Timeframe ***
                // Previous bug: Used sequential handle_index that became misaligned when CopyRates failed
                // Fix: Search g_bb_handles array to find handle matching current symbol+timeframe
                // This ensures correct BB values are ALWAYS retrieved, regardless of CopyRates failures
                int bb_handle = INVALID_HANDLE;
                for(int h = 0; h < ArraySize(g_bb_handles); h++)
                {
                    if(g_bb_handles[h].handle != INVALID_HANDLE &&
                       g_bb_handles[h].symbol == current_symbol &&
                       g_bb_handles[h].timeframe == g_timeframes[j])
                    {
                        bb_handle = g_bb_handles[h].handle;
                        break;
                    }
                }

                if(bb_handle != INVALID_HANDLE)
                {
                    if(CopyBuffer(bb_handle, 0, 1, 1, bb_middle_buffer) > 0 &&
                       CopyBuffer(bb_handle, 1, 1, 1, bb_upper_buffer) > 0 &&
                       CopyBuffer(bb_handle, 2, 1, 1, bb_lower_buffer) > 0)
                    {
                        has_bb = true;
                    }
                    else
                    {
                        // v2.01 DEBUG: Log when CopyBuffer fails
                        Print("WARNING: CopyBuffer failed for ", current_symbol, " ", EnumToString(g_timeframes[j]));
                    }
                }
                else
                {
                    // v2.01 DEBUG: Log when handle not found
                    Print("WARNING: No BB handle found for ", current_symbol, " ", EnumToString(g_timeframes[j]),
                          " (Array size: ", ArraySize(g_bb_handles), ")");
                }

                if(data_collected) json_array_payload += ",";

                json_array_payload += "{";
                json_array_payload += "\"symbol\":\"" + current_symbol + "\",";
                json_array_payload += "\"tf\":\"" + EnumToString(g_timeframes[j]) + "\",";
                json_array_payload += "\"time\":" + IntegerToString((long)rates[0].time) + ",";
                json_array_payload += "\"open\":" + DoubleToJsonString(rates[0].open, digits) + ",";
                json_array_payload += "\"high\":" + DoubleToJsonString(rates[0].high, digits) + ",";
                json_array_payload += "\"low\":" + DoubleToJsonString(rates[0].low, digits) + ",";
                json_array_payload += "\"close\":" + DoubleToJsonString(rates[0].close, digits) + ",";

                if(has_bb)
                {
                    json_array_payload += "\"bb_upper\":" + DoubleToJsonString(bb_upper_buffer[0], digits) + ",";
                    json_array_payload += "\"bb_middle\":" + DoubleToJsonString(bb_middle_buffer[0], digits) + ",";
                    json_array_payload += "\"bb_lower\":" + DoubleToJsonString(bb_lower_buffer[0], digits);
                }
                else
                {
                    json_array_payload += "\"bb_upper\":null,";
                    json_array_payload += "\"bb_middle\":null,";
                    json_array_payload += "\"bb_lower\":null";
                }

                json_array_payload += "}";

                data_collected = true;
            }
        }
    }

    if(!data_collected) return false;
    json_array_payload += "]";

    uchar post_data[];
    int json_len = StringToCharArray(json_array_payload, post_data, 0, WHOLE_ARRAY, CP_UTF8);
    ArrayResize(post_data, json_len - 1);
    char result[];
    string result_headers;

    int res = WebRequest("POST", JavaDataURL, "Content-Type: application/json", NULL, 500, post_data, ArraySize(post_data), result, result_headers);
    return(res != -1);
}

// *** PHASE 1: Duplicate tick filtering ***
bool SendAllTickData()
{
    string json_array_payload = "";
    StringReserve(json_array_payload, 2048);
    json_array_payload = "[";
    bool data_collected = false;

    for(int i = 0; i < g_symbol_count; i++)
    {
        string current_symbol = g_symbol_list[i];
        if(!SymbolSelect(current_symbol, true)) continue;

        int digits = (int)SymbolInfoInteger(current_symbol, SYMBOL_DIGITS);

        MqlTick tick;
        if(SymbolInfoTick(current_symbol, tick))
        {
            // *** PHASE 1: Skip if bid/ask unchanged ***
            if(g_last_ticks[i].last_bid == tick.bid &&
               g_last_ticks[i].last_ask == tick.ask)
            {
                continue; // No change, skip sending
            }

            // Update cache
            g_last_ticks[i].last_bid = tick.bid;
            g_last_ticks[i].last_ask = tick.ask;
            g_last_ticks[i].last_time = tick.time;

            if(data_collected) json_array_payload += ",";

            json_array_payload += "{";
            json_array_payload += "\"symbol\":\"" + current_symbol + "\",";
            json_array_payload += "\"time\":" + IntegerToString((long)tick.time) + ",";
            json_array_payload += "\"bid\":" + DoubleToJsonString(tick.bid, digits) + ",";
            json_array_payload += "\"ask\":" + DoubleToJsonString(tick.ask, digits) + ",";
            json_array_payload += "\"volume\":" + IntegerToString(tick.volume);
            json_array_payload += "}";

            data_collected = true;
        }
    }

    if(!data_collected) return false;
    json_array_payload += "]";

    uchar post_data[];
    int json_len = StringToCharArray(json_array_payload, post_data, 0, WHOLE_ARRAY, CP_UTF8);
    ArrayResize(post_data, json_len - 1);
    char result[];
    string result_headers;

    int res = WebRequest("POST", JavaTickURL, "Content-Type: application/json", NULL, 500, post_data, ArraySize(post_data), result, result_headers);
    return(res != -1);
}

// *** PHASE 1: Send current tick-level BB data separately for real-time UI display ***
bool SendAllBollingerBandsData()
{
    datetime now = TimeCurrent();
    if(now > g_last_bb_log_time + 10)  // Log every 10 seconds
    {
        Print("[BB] SendAllBollingerBandsData called at ", TimeToString(now));
        g_last_bb_log_time = now;
    }

    string json_array_payload = "";
    StringReserve(json_array_payload, 4096);
    json_array_payload = "[";
    bool data_collected = false;

    // Send BB values for ALL timeframes for each symbol
    for(int i = 0; i < ArraySize(g_bb_handles); i++)
    {
        if(g_bb_handles[i].handle == INVALID_HANDLE) continue;

        string current_symbol = g_bb_handles[i].symbol;
        ENUM_TIMEFRAMES tf = g_bb_handles[i].timeframe;
        int digits = (int)SymbolInfoInteger(current_symbol, SYMBOL_DIGITS);

        double bb_upper_buffer[];
        double bb_lower_buffer[];
        double bb_middle_buffer[];

        if(CopyBuffer(g_bb_handles[i].handle, 0, 0, 1, bb_middle_buffer) > 0 &&
           CopyBuffer(g_bb_handles[i].handle, 1, 0, 1, bb_upper_buffer) > 0 &&
           CopyBuffer(g_bb_handles[i].handle, 2, 0, 1, bb_lower_buffer) > 0)
        {
            if(data_collected) json_array_payload += ",";

            json_array_payload += "{";
            json_array_payload += "\"symbol\":\"" + current_symbol + "\",";
            json_array_payload += "\"timeframe\":\"" + EnumToString(tf) + "\",";
            json_array_payload += "\"time\":" + IntegerToString(TimeTradeServer()) + ",";
            json_array_payload += "\"bb_upper\":" + DoubleToJsonString(bb_upper_buffer[0], digits) + ",";
            json_array_payload += "\"bb_middle\":" + DoubleToJsonString(bb_middle_buffer[0], digits) + ",";
            json_array_payload += "\"bb_lower\":" + DoubleToJsonString(bb_lower_buffer[0], digits) + ",";
            json_array_payload += "\"bb_value\":0.0";
            json_array_payload += "}";

            data_collected = true;
        }
    }

    if(!data_collected)
    {
        if(now > g_last_bb_log_time + 10)
        {
            Print("[BB] No BB data collected - skipping send");
        }
        return false;
    }

    json_array_payload += "]";

    if(now > g_last_bb_log_time + 10)
    {
        Print("[BB] Sending ", ArraySize(g_symbol_list), " BB updates to ", JavaBBURL);
    }

    uchar post_data[];
    int json_len = StringToCharArray(json_array_payload, post_data, 0, WHOLE_ARRAY, CP_UTF8);
    ArrayResize(post_data, json_len - 1);
    char result[];
    string result_headers;

    int res = WebRequest("POST", JavaBBURL, "Content-Type: application/json", NULL, 500, post_data, ArraySize(post_data), result, result_headers);

    if(now > g_last_bb_log_time + 10)
    {
        if(res == -1)
        {
            int error_code = GetLastError();
            Print("[BB ERROR] WebRequest failed with error code: ", error_code);
        }
        else
        {
            Print("[BB SUCCESS] WebRequest returned ", res, " bytes");
        }
    }

    return(res != -1);
}

//+------------------------------------------------------------------+
